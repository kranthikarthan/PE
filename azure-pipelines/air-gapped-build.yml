# Air-Gapped Build Pipeline for Payment Engine
# This pipeline builds the application in an air-gapped environment
# with offline package management and container registry mirroring

trigger:
  branches:
    include:
      - main
      - develop
      - release/*
  paths:
    include:
      - services/*
      - frontend/*
      - database/*
      - infrastructure/*

variables:
  # Air-gapped environment variables
  AIRGAP_MODE: true
  OFFLINE_REGISTRY: 'airgap-registry.company.com'
  OFFLINE_NEXUS: 'airgap-nexus.company.com'
  OFFLINE_NPM_REGISTRY: 'http://airgap-nexus.company.com/repository/npm-proxy/'
  OFFLINE_MAVEN_REPO: 'http://airgap-nexus.company.com/repository/maven-public/'
  
  # Build variables
  BUILD_CONFIGURATION: 'Release'
  DOCKER_REGISTRY: 'airgap-registry.company.com'
  IMAGE_TAG: '$(Build.BuildId)'
  
  # Application variables
  APP_NAME: 'payment-engine'
  VERSION: '$(Build.BuildNumber)'

stages:
- stage: PrepareOfflinePackages
  displayName: 'Prepare Offline Packages'
  jobs:
  - job: DownloadDependencies
    displayName: 'Download Dependencies'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '18.x'
    
    - task: JavaToolInstaller@0
      displayName: 'Install Java'
      inputs:
        versionSpec: '17'
        jdkArchitectureOption: 'x64'
        jdkSourceOption: 'PreInstalled'
    
    - script: |
        echo "Setting up offline package download..."
        mkdir -p $(Pipeline.Workspace)/offline-packages
        mkdir -p $(Pipeline.Workspace)/offline-packages/npm
        mkdir -p $(Pipeline.Workspace)/offline-packages/maven
        mkdir -p $(Pipeline.Workspace)/offline-packages/docker
      displayName: 'Create Package Directories'
    
    - script: |
        echo "Downloading NPM packages..."
        cd frontend
        npm config set registry $(OFFLINE_NPM_REGISTRY)
        npm install --package-lock-only
        npm pack --pack-destination $(Pipeline.Workspace)/offline-packages/npm
      displayName: 'Download NPM Packages'
    
    - script: |
        echo "Downloading Maven dependencies..."
        cd services
        mvn dependency:go-offline -Dmaven.repo.local=$(Pipeline.Workspace)/offline-packages/maven
        mvn dependency:copy-dependencies -DoutputDirectory=$(Pipeline.Workspace)/offline-packages/maven/lib
      displayName: 'Download Maven Dependencies'
    
    - script: |
        echo "Downloading Docker base images..."
        docker pull openjdk:17-jdk-slim
        docker pull node:18-alpine
        docker pull postgres:15-alpine
        docker pull redis:7-alpine
        docker pull nginx:alpine
        
        # Save images for offline transfer
        docker save openjdk:17-jdk-slim > $(Pipeline.Workspace)/offline-packages/docker/openjdk-17-jdk-slim.tar
        docker save node:18-alpine > $(Pipeline.Workspace)/offline-packages/docker/node-18-alpine.tar
        docker save postgres:15-alpine > $(Pipeline.Workspace)/offline-packages/docker/postgres-15-alpine.tar
        docker save redis:7-alpine > $(Pipeline.Workspace)/offline-packages/docker/redis-7-alpine.tar
        docker save nginx:alpine > $(Pipeline.Workspace)/offline-packages/docker/nginx-alpine.tar
      displayName: 'Download Docker Base Images'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Offline Packages'
      inputs:
        pathToPublish: '$(Pipeline.Workspace)/offline-packages'
        artifactName: 'offline-packages'
        publishLocation: 'Container'

- stage: BuildApplication
  displayName: 'Build Application'
  dependsOn: PrepareOfflinePackages
  jobs:
  - job: BuildServices
    displayName: 'Build Backend Services'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: JavaToolInstaller@0
      displayName: 'Install Java'
      inputs:
        versionSpec: '17'
        jdkArchitectureOption: 'x64'
        jdkSourceOption: 'PreInstalled'
    
    - download: current
      artifact: offline-packages
    
    - script: |
        echo "Setting up offline Maven repository..."
        mkdir -p ~/.m2/repository
        cp -r $(Pipeline.Workspace)/offline-packages/maven/* ~/.m2/repository/
      displayName: 'Setup Offline Maven Repository'
    
    - script: |
        echo "Building backend services..."
        cd services
        mvn clean package -DskipTests -Dmaven.repo.local=~/.m2/repository
      displayName: 'Build Backend Services'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend Artifacts'
      inputs:
        pathToPublish: 'services/target'
        artifactName: 'backend-artifacts'
        publishLocation: 'Container'
  
  - job: BuildFrontend
    displayName: 'Build Frontend'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '18.x'
    
    - download: current
      artifact: offline-packages
    
    - script: |
        echo "Setting up offline NPM registry..."
        npm config set registry $(OFFLINE_NPM_REGISTRY)
        cd frontend
        npm ci --offline
      displayName: 'Install Frontend Dependencies'
    
    - script: |
        echo "Building frontend..."
        cd frontend
        npm run build
      displayName: 'Build Frontend'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend Artifacts'
      inputs:
        pathToPublish: 'frontend/dist'
        artifactName: 'frontend-artifacts'
        publishLocation: 'Container'

- stage: BuildContainers
  displayName: 'Build Container Images'
  dependsOn: BuildApplication
  jobs:
  - job: BuildDockerImages
    displayName: 'Build Docker Images'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - download: current
      artifact: offline-packages
    
    - download: current
      artifact: backend-artifacts
    
    - download: current
      artifact: frontend-artifacts
    
    - script: |
        echo "Loading base images..."
        docker load < $(Pipeline.Workspace)/offline-packages/docker/openjdk-17-jdk-slim.tar
        docker load < $(Pipeline.Workspace)/offline-packages/docker/node-18-alpine.tar
        docker load < $(Pipeline.Workspace)/offline-packages/docker/postgres-15-alpine.tar
        docker load < $(Pipeline.Workspace)/offline-packages/docker/redis-7-alpine.tar
        docker load < $(Pipeline.Workspace)/offline-packages/docker/nginx-alpine.tar
      displayName: 'Load Base Images'
    
    - script: |
        echo "Building application images..."
        
        # Build payment-processing service
        docker build -t $(DOCKER_REGISTRY)/$(APP_NAME)-payment-processing:$(IMAGE_TAG) \
          -f services/payment-processing/Dockerfile.airgap \
          --build-arg JAR_FILE=target/payment-processing-*.jar \
          services/payment-processing/
        
        # Build payment engine service
        docker build -t $(DOCKER_REGISTRY)/$(APP_NAME)-payment-engine:$(IMAGE_TAG) \
          -f services/payment-engine/Dockerfile.airgap \
          --build-arg JAR_FILE=target/payment-engine-*.jar \
          services/payment-engine/
        
        # Build frontend
        docker build -t $(DOCKER_REGISTRY)/$(APP_NAME)-frontend:$(IMAGE_TAG) \
          -f frontend/Dockerfile.airgap \
          frontend/
      displayName: 'Build Application Images'
    
    - script: |
        echo "Saving images for offline transfer..."
        mkdir -p $(Pipeline.Workspace)/application-images
        
        docker save $(DOCKER_REGISTRY)/$(APP_NAME)-payment-processing:$(IMAGE_TAG) > \
          $(Pipeline.Workspace)/application-images/payment-processing-$(IMAGE_TAG).tar
        
        docker save $(DOCKER_REGISTRY)/$(APP_NAME)-payment-engine:$(IMAGE_TAG) > \
          $(Pipeline.Workspace)/application-images/payment-engine-$(IMAGE_TAG).tar
        
        docker save $(DOCKER_REGISTRY)/$(APP_NAME)-frontend:$(IMAGE_TAG) > \
          $(Pipeline.Workspace)/application-images/frontend-$(IMAGE_TAG).tar
      displayName: 'Save Application Images'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Application Images'
      inputs:
        pathToPublish: '$(Pipeline.Workspace)/application-images'
        artifactName: 'application-images'
        publishLocation: 'Container'

- stage: CreateDeploymentPackage
  displayName: 'Create Deployment Package'
  dependsOn: BuildContainers
  jobs:
  - job: PackageDeployment
    displayName: 'Package Deployment'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - download: current
      artifact: application-images
    
    - script: |
        echo "Creating deployment package..."
        mkdir -p $(Pipeline.Workspace)/deployment-package
        
        # Copy application images
        cp -r $(Pipeline.Workspace)/application-images/* $(Pipeline.Workspace)/deployment-package/
        
        # Copy deployment manifests
        cp -r infrastructure/kubernetes/* $(Pipeline.Workspace)/deployment-package/
        cp -r infrastructure/helm/* $(Pipeline.Workspace)/deployment-package/
        
        # Copy database migrations
        cp -r database/migrations/* $(Pipeline.Workspace)/deployment-package/
        
        # Create deployment script
        cat > $(Pipeline.Workspace)/deployment-package/deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Starting air-gapped deployment..."
        
        # Load application images
        echo "Loading application images..."
        docker load < payment-processing-*.tar
        docker load < payment-engine-*.tar
        docker load < frontend-*.tar
        
        # Tag images for local registry
        docker tag airgap-registry.company.com/payment-engine-payment-processing:* local-registry:5000/payment-engine-payment-processing:latest
        docker tag airgap-registry.company.com/payment-engine-payment-engine:* local-registry:5000/payment-engine-payment-engine:latest
        docker tag airgap-registry.company.com/payment-engine-frontend:* local-registry:5000/payment-engine-frontend:latest
        
        # Push to local registry
        docker push local-registry:5000/payment-engine-payment-processing:latest
        docker push local-registry:5000/payment-engine-payment-engine:latest
        docker push local-registry:5000/payment-engine-frontend:latest
        
        # Apply Kubernetes manifests
        echo "Applying Kubernetes manifests..."
        kubectl apply -f kubernetes/
        
        # Install Helm charts
        echo "Installing Helm charts..."
        helm upgrade --install payment-engine helm/payment-engine \
          --set image.registry=local-registry:5000 \
          --set image.tag=latest
        
        echo "Deployment completed successfully!"
        EOF
        
        chmod +x $(Pipeline.Workspace)/deployment-package/deploy.sh
      displayName: 'Create Deployment Package'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Deployment Package'
      inputs:
        pathToPublish: '$(Pipeline.Workspace)/deployment-package'
        artifactName: 'deployment-package'
        publishLocation: 'Container'